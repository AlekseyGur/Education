# Задание 5
#
# Представлен список чисел. Определить элементы списка, не имеющие повторений. Сформировать из этих элементов список с сохранением порядка их следования в исходном списке, например:
#
# src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# result = [23, 1, 3, 10, 4, 11]
#
# Подсказка: напишите сначала решение «в лоб». Потом подумайте об оптимизации.
#
# ВНИМАНИЕ! Используйте стартовый код для своей реализации:
#
# def get_uniq_numbers(src: list):
#     pass
#
#
# src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# print(*get_uniq_numbers(src))


def get_uniq_numbers(src: list) -> list:
    return [i for i in src if src.count(i) < 2]

src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
print(*get_uniq_numbers(src))


# ниже приведён альтернативный способ. Не знаю почему, но так и не удалось адекватно время выполнения кода. Такое ощущение, что каждый раз при выполнении кода из файла, первый вариант исполнения get_uniq_numbers срабатывает медленнее. Даже если менять примеры местами. Возможно, это происходит из-за каких-то механизмов врое кеширования внутри CPU?
# Если и оценивать скорость работы кода, то необходимо запускать один и тот же код раз 100, вычисляя среднее по этому значению и стандартное отклонение, чтобы сделать хоть какие-то выводы о скорости работы.


def get_uniq_numbers(src: list) -> list:
    """Создаёт список из уникальных элементов получаемого списка src, сохраняя относительное положение элементов. Работает только со списками из целых чисел."""
    tmp = [None] * (max(src) + 1)
    for i in src:
        if tmp[i]:
            tmp[i] += 1
        else:
            tmp[i] = 1

    return [i for i in src if tmp[i] == 1]

src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
print(*get_uniq_numbers(src))
