# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
#
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6          8    3    7    1
# 51    86        -1   64   -8
#
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
#
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:
    def __init__(self, list_of_lists: list = [[]]):
        self.list_of_lists = list_of_lists

    def __str__(self):
        a = ''
        for list_part in self.list_of_lists:
            for el in list_part:
                a += ' ' + str(el)
            a += '\n'
        return a

    def __iter__(self):
        return self

    def __next__(self):
        x = 0
        while x < len(self.list_of_lists):
            yield self.list_of_lists[x]
            x += 1
        else:
            raise StopIteration

    def __add__(self, other) -> list:
        if isinstance(other, Matrix):
            a = self.list_of_lists.copy()
            for i, row in enumerate(self.list_of_lists):
                for j, val in enumerate(row):
                    a[i][j] = val + other.get(i,j, 0)

            return a

    def get(self, x: int = 0, y: int = 0, default: int = 0) -> int:
        if x < len(self.list_of_lists):
            if y < len(self.list_of_lists[x]):
                return self.list_of_lists[x][y]
        return default

m1 = Matrix( [[31,32],
              [37,43],
              [51,86]] )

m2 = Matrix( [[3,  5,  32],
              [2,  4,  6],
              [-1,-64,-8]] )

m3 = Matrix( [[3,5,8,3],
              [8,3,7,1]] )

print(m1 + m2)
print(m1 + m3)


# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod

class Cloth(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def estimate(self):
        pass

class Coat(Cloth):
    def __init__(self, V: int = 0):
        self.V = V

    @property
    def estimate(self) -> int:
        return self.V / 6.5 + 0.5

class Costume(Cloth):
    def __init__(self, H: int = 0):
        self.H = H

    @property
    def estimate(self) -> int:
        return self.H * 2 + 0.5


m1 = Coat(6.5)
m2 = Costume(2)

print(m1.estimate)
print(m2.estimate)


# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
#
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****.

class Cell:
    def __init__(self, parts: int = 5):
        self.parts = parts

    def __add__(self, other):
        if isinstance(other, Cell):
            return Cell(self.parts + other.parts)

    def __sub__(self, other):
        if isinstance(other, Cell):
            if self.parts < other.parts:
                return 'Разность количества ячеек двух клеток меньше нуля'
            else:
                return Cell(self.parts - other.parts)

    def __mul__(self, other):
        if isinstance(other, Cell):
            return Cell(self.parts * other.parts)

    def __truediv__(self, other):
        if isinstance(other, Cell):
            return Cell(self.parts // other.parts)

    def __str__(self):
        return 'Ячейки клетки: \n' + str(self.make_order())

    def make_order(self, n: int = 5) -> str:
        a = ''
        for i in range(1, self.parts+1):
            a += '*'
            if i % n == 0:
                a += '\n'

        return a


c1 = Cell(7)
c2 = Cell(6)
c3 = Cell(12)

print(c1 + c2)
print(c3 - c2)
print(c1 * c2)
print(c3 / c1)
