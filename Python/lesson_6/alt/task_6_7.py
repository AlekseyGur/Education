# Задание 7 *(вместо 6)
#
# Добавить возможность редактирования данных при помощи отдельного скрипта change_sale.py: передаём ему номер записи и новое значение (нумерация записей начинается с 1.).
#
#     При этом файл не должен читаться целиком — обязательное требование!!
#
# Предусмотреть ситуацию, когда пользователь вводит номер записи, которой не существует.
#
# Задание 6
#
# Реализовать простую систему хранения данных о суммах продаж булочной. Должно быть два скрипта add_sale.py и show_sales.py с интерфейсом командной строки: для записи данных и для вывода на экран записанных данных. При записи передавать из командной строки значение суммы продаж.
#
# Для чтения данных реализовать в командной строке следующую логику:
#
#     просто запуск скрипта — выводить все записи;
#     запуск скрипта с одним параметром-числом — выводить все записи с номера, равного этому числу, до конца;
#     запуск скрипта с двумя числами — выводить записи, начиная с номера, равного первому числу, по номер, равный второму числу, включительно.
#
# Подумать, как избежать чтения всего файла при реализации второго и третьего случаев. Данные хранить в файле bakery.csv в кодировке utf-8. Нумерация записей начинается с 1.
#
# Примеры запуска скриптов:
#
# $ python add_sale.py 5978,5
# $ python add_sale.py 8914,3
# $ python add_sale.py 7879,1
# $ python add_sale.py 1573,7
# $ python show_sales.py
# 5978,5
# 8914,3
# 7879,1
# 1573,7
# $ python show_sales.py 3
# 7879,1
# 1573,7
# $ python show_sales.py 1 3
# 5978,5
# 8914,3
# 7879,1



# содержимое файла add_sale.py
import sys

if len(sys.argv) < 2:
    print('''Недостаточно аргументов.
             Передайте аргументом сумму продаж для записи''')
    exit(0)


with open('sales', 'a', encoding='utf-8') as fw:
    # Делаем сохраняемые строки одинаковой длины. Потому что при изменении
    # одного значения без чтения всего файла приходится заменять байты. Иначе
    # будет перезаписана не одна строка, а несколько
    fw.write(sys.argv[1].strip().zfill(10) + '\n')



# содержимое файла show_sales.py
import sys

with open('sales', encoding='utf-8') as f:
    for i, line in enumerate(f, 1):
        if len(sys.argv) == 2 and i < int(sys.argv[1]):
            continue

        if len(sys.argv) == 3 and (i < int(sys.argv[1]) or int(sys.argv[2]) < i):
            continue

        print(line.rstrip())



# содержимое файла change_sale.py
import sys
if len(sys.argv) < 3:
    print('''Недостаточно аргументов.
             Передайте аргументом номер строки для изменения и новое значение''')
    exit(0)

request_number = int(sys.argv[1])
with open('sales', 'r+', encoding='utf-8') as f:
    start = None
    i = 1
    line = f.readline() # обход ошибки вызова tell() - OSError: telling position disabled by next() call
    if request_number == 1:
        start = 0
    else:
        while line:
            i += 1
            if i == request_number:
                start = f.tell()
                break
            line = f.readline()

    if start != None:
        f.seek(start)

        # Делаем сохраняемые строки одинаковой длины. Потому что при изменении
        # одного значения без чтения всего файла приходится заменять байты. Иначе
        # будет перезаписана не одна строка, а несколько
        f.write(sys.argv[2].strip().zfill(10) + '\n')
    else:
        print('Такой строки не существует')
